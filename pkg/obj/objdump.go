package obj

import (
	"bufio"
	"fmt"
	"io"
	"iter"
	"os"
	"slices"
	"strconv"
	"strings"
	"unicode"
)

type Instruction struct {
	source string // E.g., "compare_native.go:8" or ":-5"
	offset uint64 // The address of the instruction
	opcode uint64 // The raw opcode bytes (in hex)
	name   string // E.g, "PUSHQ R13"
}

func NewInstruction(source string, offset uint64, opcode uint64, instruction string) Instruction {
	return Instruction{
		source, offset, opcode, instruction,
	}
}

func (instruction Instruction) Source() string {
	return instruction.source
}

func (instruction Instruction) Name() string {
	return instruction.name
}

func (instruction Instruction) Offset() uint64 {
	return instruction.offset
}

func (instruction Instruction) End() uint64 {
	return instruction.Offset() + 4
}

func (instruction Instruction) Opcode() uint64 {
	return instruction.opcode
}

func (instruction Instruction) IsUnkown() bool {
	return instruction.name == "?"
}

type Function struct {
	section       string        // E.g., "TEXT"
	qualifiedName string        // E.g., "runtime/cgo(.text)(SB)"
	source        string        // E.g., "/usr/local/go/src/internal/cpu/cpu.go"
	instructions  []Instruction // The sequence (in order) of the instructions the function consists of
	pkg           string
	receiver      string
	identifier    string
}

func NewFunction(section string, qualifiedName string, source string, instructions ...Instruction) Function {
	pkg, receiver, identifier := ParseQualifiedName(qualifiedName)
	return Function{
		section:       section,
		qualifiedName: qualifiedName,
		source:        source,
		instructions:  instructions,
		pkg:           pkg,
		receiver:      receiver,
		identifier:    identifier,
	}
}

func (function Function) IsEmpty() bool {
	return len(function.instructions) == 0
}

func (function Function) Section() string {
	return function.section
}

func (function Function) QualifiedName() string {
	return function.qualifiedName
}

func (function Function) Source() string {
	return function.source
}

func (function Function) Start() uint64 {
	if len(function.instructions) > 0 {
		return function.instructions[0].Offset()
	}
	return 0
}

func (function Function) End() uint64 {
	if len(function.instructions) > 0 {
		return function.instructions[len(function.instructions)-1].End()
	}
	return 0
}

func (function Function) Length() uint64 {
	return function.End() - function.Start()
}

func (function Function) Instructions() []Instruction {
	return function.instructions
}

func (function Function) Package() string {
	return function.pkg
}

func (function Function) Receiver() string {
	return function.receiver
}

func IsIdentifier(str string) bool {
	if len(str) == 0 {
		return false
	}

	for i, r := range str {
		if (i == 0 && !(r == '_' || unicode.IsLetter(r) || !unicode.IsDigit(r))) {
			return false
		}
		if (i > 0 && !(r == '_' || unicode.IsLetter(r) || unicode.IsDigit(r))) {
			return false
		}
	}

	return true
}

func IsReceiver(str string) bool {
	if IsIdentifier(str) {
		return true
	}

	return IsIdentifier(strings.TrimLeft(strings.TrimRight(str, ")"),"(*"))
}

func IsNumber(str string) bool {
	if len(str) == 0 {
		return false
	}

	for _, r := range str {
		if !unicode.IsDigit(r) {
			return false
		}
	}

	return true
}

func (function Function) Function() string {
	return function.identifier
}

func (function Function) IsType() bool {
	return strings.HasPrefix(function.QualifiedName(), "type:")
}

func (function Function) IsAutogenerated() bool {
	return function.Source() == "<autogenerated>"
}

func (function Function) IsCGO() bool {
	return strings.HasPrefix(function.Function(), "_cgo_")
}

func (function Function) IsXCGO() bool {
	return strings.HasPrefix(function.Function(), "x_cgo_")
}

type Dump struct {
	functions []Function // The sequence (in order) of the functions in the objdump
}

func New(functions ...Function) Dump {
	return Dump{
		functions,
	}
}

func (objdump Dump) Size() int {
	return len(objdump.functions)
}

func (objdump Dump) Functions() iter.Seq2[int, Function] {
	return slices.All(objdump.functions)
}

func (objdump Dump) FilterFunc(filter func(function Function) bool) (functions []Function) {
	for _, function := range objdump.Functions() {
		if filter(function) {
			functions = append(functions, function)
		}
	}
	return
}

func (objdump Dump) InPackage(pack string) []Function {
	return objdump.FilterFunc(func(function Function) bool {
		return function.Package() == pack
	})
}

func (objdump Dump) FunctionInPackage(pack, name string) []Function {
	return objdump.FilterFunc(func(function Function) bool {
		return function.Package() == pack && function.Function() == name
	})
}

func (objdump Dump) FirstFunctionInPackage(pack, name string) Function {
	return objdump.FunctionInPackage(pack, name)[0]
}

func (objdump Dump) FunctionInPackageWithReceiver(pack, receiver, name string) []Function {
	return objdump.FilterFunc(func(function Function) bool {
		return function.Package() == pack && function.Function() == name && function.Receiver() == receiver
	})
}

func splitN(s, sep string, n int) (splitN []string) {
	parts := strings.Split(s, sep)

	counter := 0
	for _, part := range parts {
		counter++
		trimmed := strings.TrimSpace(part)
		if trimmed != "" {
			splitN = append(splitN, trimmed)
			if n > 0 && len(splitN) == n-1 {
				break
			}
		}
	}

	if n > 0 && len(splitN) == n-1 {
		remaining := strings.Join(parts[counter:], sep)
		splitN = append(splitN, strings.TrimSpace(remaining))
	}

	return
}

func ParseFunctionline(line string) (section string, qualifiedName string, source string) {
	line = strings.TrimSpace(line)
	line = strings.ReplaceAll(line, "\t", " ")

	if line == "" {
		return
	}

	firstSpace := strings.Index(line, " ")
	lastSpace := strings.LastIndex(line, " ")

	section = strings.TrimSpace(line[:firstSpace])
	if lastSpace > firstSpace {
		qualifiedName = strings.TrimSpace(line[firstSpace:lastSpace])
		source = strings.TrimSpace(line[lastSpace:])
	} else {
		qualifiedName = strings.TrimSpace(line[firstSpace:])
	}

	return
}

func ParseQualifiedName(name string) (pkg, receiver, function string) {
	prefix := name

	if strings.HasPrefix(prefix, "type:.") {
		prefix = strings.TrimPrefix(prefix, "type:.")
		split := strings.Split(prefix, ".")
		return "", "", split[0]
	}

	prefix = strings.TrimRight(prefix, "(SB)")

	if index := strings.Index(prefix, "["); index >= 0 {
		prefix = prefix[:index]
	}

	split := strings.Split(prefix, ".")
	split = slices.DeleteFunc(split, IsNumber)

	// It may be an anonymous function or defered function. E.g., "deferwrap1" and "func1"
	offset := 0
	if strings.HasPrefix(split[len(split)-1], "deferwrap") {
		offset = 1
	} else if strings.HasPrefix(split[len(split)-1], "func") {
		offset = 1
	}

	if offset == 1 {
		identifierIndex := len(split) - 1 - offset
		// TODO: Maybe this wont work with functions with anon functions and a receiver.

		if index := identifierIndex - 2; index >= 0 {
			pkg = strings.Join(split[:index+1], ".")
			if index := identifierIndex - 1; index >= 0 {
				receiver = split[index]
			}
		} else {
			if index := identifierIndex - 1; index >= 0 {
				pkg = strings.Join(split[:index+1], ".")
			}
		}
		if index := identifierIndex; index >= 0 {
			function = strings.Join(split[index:], ".")
		}

		return
	}

	if index := len(split) - 3; index >= 0 {
		pkg = strings.Join(split[:index+1], ".")
		if index := len(split) - 2; index >= 0 {
			receiver = split[index]
		}
	} else {
		if index := len(split) - 2; index >= 0 {
			pkg = strings.Join(split[:index+1], ".")
		}
	}
	if index := len(split) - 1; index >= 0 {
		function = strings.Join(split[index:], ".")
	}

	if len(receiver) > 0 && !IsReceiver(receiver) {
		pkg = fmt.Sprintf("%s.%s", pkg, receiver)
		receiver = ""
	}

	return
}

func ParseInstructionLine(line string) (source string, offset uint64, opcode uint64, name string) {
	line = strings.TrimSpace(line)
	line = strings.ReplaceAll(line, "\t", " ")
	split := splitN(line, " ", 4)

	if len(split) > 0 {
		source = split[0]
	}

	if len(split) > 1 && len(split[1]) > 1 {
		var err error
		offset, err = strconv.ParseUint(split[1][2:], 16, 64)
		if err != nil {
			panic(err)
		}
	}

	if len(split) > 2 {
		var err error
		opcode, err = strconv.ParseUint(split[2], 16, 64)
		if err != nil {
			panic(err)
		}
	}

	if len(split) > 3 {
		name = split[3]
	}

	return
}

func ParseFile(path string) (Dump, error) {
	file, err := os.Open(path)
	if err != nil {
		var zero Dump
		return zero, err
	}
	defer file.Close()

	dump, err := Parse(file)
	if err != nil {
		var zero Dump
		return zero, err
	}

	return dump, nil
}

func Parse(reader io.Reader) (Dump, error) {
	scanner := bufio.NewScanner(reader)
	var functions []Function
	line := 0

	for scanner.Scan() {
		line++

		functionLine := scanner.Text()
		if strings.TrimSpace(functionLine) == "" {
			continue
		}

		section, qualifiedName, source := ParseFunctionline(functionLine)

		var instructions []Instruction

		for scanner.Scan() {
			line++

			instructionLine := scanner.Text()
			if strings.TrimSpace(instructionLine) == "" {
				break
			}

			source, offset, opcode, instruction := ParseInstructionLine(scanner.Text())
			instructions = append(instructions, NewInstruction(source, offset, opcode, instruction))
		}

		functions = append(functions, NewFunction(section, qualifiedName, source, instructions...))

	}

	return New(functions...), nil
}
